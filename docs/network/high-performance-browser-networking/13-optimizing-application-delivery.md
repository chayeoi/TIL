# 13장 애플리케이션 전송 최적화

클라이언트와 서버 사이에서 발생하는 네트워크의 가변적인 상황이나 클라이언트의 하드웨어 사양 혹은 기기의 설정 값을 제어할 수는 없다. 그러나 서버상의 TCP와 TLS의 최적화, 그리고 여러 물리 계층의 특성을 고려하여 설계된 애플리케이션의 최적화 기법, HTTP 프로토콜 버전, 그리고 통상적으로 활용할 수 있는 애플리케이션의 개발 지침 등은 제어할 수 있는 범위 내에 있다.

대부분의 웹 애플리케이션의 성능은 대역폭의 크기가 아닌 레이턴시에 의해서 제한을 받게 된다. 데이터를 더 빨리 이동시킬 수는 없어도 전송 계층과 애플리케이션 계층에 적용할 수 있는 모든 최적화를 동원하여 불필요한 요청과 왕복시간을 없애고, 서버를 클라이언트와 가까운 곳에 위치시킴으로써 패킷의 이동거리를 최소화하는 것이 무엇보다 중요하다.

특히 무선 네트워크에서는 레이턴시가 높고 대역폭을 확보하기 어렵기 때문에, 이러한 물리 계층의 고유 특성을 살린 최적화를 통해서 애플리케이션의 성능을 전반적으로 향상시킬 수 있다.

## 성능 지침의 표본

모든 애플리케이션들은 네트워크의 종류나 네트워킹 프로토콜 버전, 혹은 프로토콜 종류와 상관없이 언제나 불필요한 네트워크 레이턴시를 줄이고 전송 데이터의 바이트 수를 최소화해야 한다.

### DNS 룩업을 줄여라

모든 호스트명 룩업에는 네트워크 왕복시간이 소요되므로 요청이 있을 때마다 레이턴시가 발생하고 룩업이 진행 중일 때에는 다른 요청의 진행을 블로킹하게 된다.

### TCP 커넥션을 재사용하라

커넥션 킵얼라이브를 최대한으로 활용하면 TCP 핸드셰이크와 느린 시작 레이턴시 오버헤드를 줄일 수 있다.

### HTTP 리다이렉션 수를 최소화하라

클라이언트를 다른 호스트명으로 리디렉션할 때에는 DNS 룩업, TCP 핸드셰이크 레이턴시가 추가로 발생한다.

### CDN을 이용하라

데이터를 클라이언트와 지역적으로 가까운 곳에 위치시킴으로써 모든 TCP 커넥션의 네트워크 레이턴시를 대폭 줄일 수 있고 처리량도 증가한다.

### 불필요한 리소스를 제거하라

### 클라이언트에서 리소스를 캐시하라

- Cache-Control 헤더는 리소스의 캐시 수명(max-age)을 지정할 수 있다.
- Last-Modified와 ETag 헤더는 유효성 검사 메커니즘을 제공한다.

캐시 수명과 유효성 체크 방식 모두 지정해야 한다는 것을 명심하자. 사람들이 흔히 하는 실수가 바로 이 두 헤더 정보 중 한 가지를 제공하지 않는 것인데, 이럴 경우 바뀌지 않은 리소스를 불필요하게 전송하게 되거나(유효성 정보가 없을 경우), 혹은 리소스가 사용되었는지 매번 유효성 검사를 하게 될 것이다(캐시 수명 정보가 없을 경우).

### 전송된 데이터를 압축하라

만약 리소스가 만기됐거나 리소스를 캐시에 저장할 수 없어서 다시 한번 리소스를 얻어 와야 하는 경우에는, 최소한의 바이트를 전송해야만 한다. 언제나 모든 리소스에 가장 좋은 압축방식을 적용하라.

- HTML, CSS, 자바스크립트와 같은 텍스트 기반의 리소스는 Gzip으로 압축했을 경우, 그 크기가 평균 60% ~ 80%까지 줄어든다.
- 이미지의 경우에는 조금 더 고려해야 할 사항들이 있다.
  - 이미지니는 평균적으로 전송되는 페이지의 반 이상을 차지한다.
  - 이미지의 불필요한 메타데이터를 제거하여 파일의 크기를 줄일 수 있다.
  - 서버에서 이미지 사이즈를 재조정하여 불필요한 바이트 전송을 피해야 한다.
  - 이미지의 종류에 따라 가장 적합한 파일 형식을 선택해야 한다.
  - 가능한 경우에는 언제나 손실 압축을 사용해야 한다.

각 이미지마다 최적의 형식을 고를 수 있도록 적절한 도구와 자동화 작업에 투자해야 한다. 알맞은 이미지 형식을 선택한 후에는 이미지 파일의 크기가 불필요하게 크지 않도록 리사이징해야 한다. 큰 이미지를 클라이언트에서 리사이징하면 CPU, GPU, 메모리에 좋지 않은 영향을 줄 뿐만 아니라 전송할 파일의 크기도 커진다.

알맞은 이미지 형식을 선택하고 최소한의 이미지 크기로 리사이징한 다음에는 JPEG나 WebP와 같은 압축률을 얻을 수 있는 손실압축 방식을 사용해야 한다. 높은 압축률로 압축한 이미지는 바이트 수를 대폭 줄일 수 있을 뿐만이 아니라, 특히 모바일과 같은 작은 스크린에서는 시각적으로 이미지의 품질에 거의 영향을 주지 않는다.

### 불필요한 요청 데이터 자체를 없애라

HTTP 헤더 데이터(예: HTTP 쿠키)를 줄이면 전체 네트워크 레이턴시를 줄일 수 있다.

표준에서는 한 사이트에서 요청 지점당 여러 쿠키를 보유할 수 있게 허락하고 있어서, 수십 킬로바이트의 임의의 메타데이터가 여러 쿠키에 걸쳐 쪼개져 있을 수도 있다. 말할 것도 없이 이는 애플리케이션에 심각한 성능 저해를 불러온다.

- 쿠키 데이터는 요청이 있을 때마다 브라우저에서 자동으로 전송한다.
- HTTP 1.x에서는 쿠키를 포함한 모든 HTTP 헤더가 압축되지 않은 채로 전송된다.
- HTTP 2.0에서는 압축이 적용되지만 여전히 오버헤드가 높다.
- 최악의 경우에는 커다란 HTTP 쿠키가 초기 TCP 혼잡 윈도 사이즈를 초과하여 네트워크 레이턴시에 왕복시간을 추가로 유바할 수 있다.

쿠키의 크기는 신중하게 관찰되어야 한다. 보안 세션 토큰처럼 꼭 필요한 데이터만을 전송하고, 서버의 공유 세션 캐시를 활용하여 메타데이터를 검색하도록 하라. 가능하다면 쿠키를 아예 없애는 것도 하나의 방법이다.

### 요청과 응답을 병렬로 처리하라

- 커넥션 킵얼라이브를 사용하고 HTTP1.0을 HTTP1.1로 업그레이드하라.
- 가능한 한 여러 개의 HTTP1.1 커넥션을 활용하여 다운로드를 병렬로 처리하라.
- 가능할 때마다 HTTP1.1 파이프라이닝을 활용하라.
- 성능 개선을 위해 HTTP2.0로 업그레이드할 수 있는지 살펴보라.
- 서버가 요청을 병렬로 처리할 수 있을 만한 리소스가 충분히 있는지 확인하라.

커넥션 킵얼라이브가 없다면, HTTP 요청이 있을 때마다 새 TCP 커넥션이 필요하기 때문에 TCP 핸드셰이크와 느린 시작(slow-start)으로 인한 오버헤드가 발생하게 된다.

### 프로토콜 고유의 최적화를 적용하라

HTTP 1.x에서는 병렬 작업이 매우 제한적으로 제공된다. 따라서 여러 리소스를 하나로 묶거나 여러 도메인에 걸쳐 리소스를 쪼개어 전송하는 등의 작업이 필요하다. 반면에 HTTP 2.0에서는 이러한 방식을 사용하지 않고 하나의 커넥션을 사용해야만 최고의 성능을 얻을 수 있다.

## HTTP 1.x 최적화

성능 최적화 수치를 가지고 애플리케이션 내에서 최적의 성능을 위한 작업이 끝나면, 애플리케이션이 HTTP1.x 전용의 최적화 기법을 적용하는 것이 성능에 혜택이 있는지 판단해야 한다.

### HTTP 파이프라이닝을 활용하라

### 도메인 샤딩을 적용하라

### 리소스를 하나로 묶어 HTTP 요청 수를 줄여라

### 크기가 작은 리소스들을 문서에 포함시켜라

## HTTP 2.0의 최적화

HTTP2.0은 클라이언트와 서버 간에 전송 성능을 높이고 낮은 레이턴시와 높은 처리량을 얻어내는 것에 초점을 맞추고 있다. 그렇기 때문에 TCP와 TLS으 성능을 최대로 끌어내는 것은 물론, 다른 불필요한 네트워크 레이턴시를 없애는 것은 매우 중요하다.

도메인 샤딩, 결합, 이미지 스프라이팅 등의 나쁜 버릇을 고치도록 하자. 이러한 임기응변들은 HTTP2.0에서는 더 이상 필요하지 않다.

### 1.x 최적화를 없애기

#### 한 요청 지점당 하나의 커넥션을 사용하라

HTTP 2.0은 하나의 TCP 커넥션의 처리량을 최대화하여 성능을 개선하였다. 오히려 도메인 샤딩과 같이 여러 개의 커넥션을 사용하게 되면 프로토콜에서 제공하는 헤더 압축과 요청 우선순위 기능의 효과가 떨어지기 때문에 HTTP2.0의 성능을 저해하게 된다.

#### 불필요한 파일 결합과 이미지 스프라이팅을 없애라

리소스 번들링에는 많은 단점이 존재한다. 캐시 무효화 비용도 크고, 메모리 소모도 많으며, 파일 실행 속도도 지연되고, 또 애플리케이션의 복잡성도 커지게 된다. HTTP2.0에서는 크기가 작은 수많은 파일들을 멀티플렉싱할 수 있게 되었기 때문에, 굳이 이러한 단점을 감수하면서 리소스 번들링을 이용할 이유가 없어졌다.

#### 서버 푸시를 활용하라

HTTP 1.x에서 인라이닝을 사용했던 대부분의 리소스들은 서버 푸시를 통해 전송해야만 한다. 서버 푸시를 이용하면 클라이언트가 각 리소스를 캐시에 저장하여 여러 페이지에 걸쳐 재사용할 수 있다.

최고의 성능을 위해서는 같은 요청 지점에 가능한 한 많은 리소스를 모아야 한다. 도메인 샤딩은 HTTP2.0에서는 프로토콜의 성능을 저해하는 요소가 된다.

리소스 인라이닝은 서버 푸시로 대체하면 추가적인 네트워크 레이턴시를 유발하지 않고 클라이언트의 캐시 성능을 개선할 수 있다.

### 듀얼 프로토콜 애플리케이션 전략

HTTP2.0으로의 업그레이드는 하루아침에 일어나지는 않을 것이다. 따라서 대부분의 애플리케이션은 두 프로토콜을 모두 활용하는 듀얼 프로토콜 전략을 고려해야 할 것이다.

두 프로토콜을 모두 지원하기 위해서 복합적이고 자동적으로 수행되는 전략을 사용해야만 할 것이다.

#### 동일한 애플리케이션 코드와 듀얼 프로토콜 사용

동일한 애플리케이션 코드를 HTTP1.x과 HTTP2.0을 통해 전송할 수 있다. 결과적으로 두 프로토콜 모두에게서 최상의 결과를 얻을 수는 없겠지만, 두 가지 프로토콜 모두에게서 어느 정도 괜찮은 성능을 얻을 수 있는 가장 실용적인 방법이라 할 수 있다. 우선 1.x 위주의 기능인 도메인 샤딩을 제거하여 HTTP2.0의 전송을 원활하게 만들어야 한다. 추후에 HTTP2.0 사용자의 비중이 높아지면 점차적으로 리소스 번들링 기술 또한 2.0의 서버 푸시 기능으로 대체할 수 있을 것이다.

#### 별개의 애플리케이션 코드와 듀얼 프로토콜 사용

사용하는 프로토콜의 버전에 따라서 다른 버전의 애플리케이션을 전송할 수 있다. 이 전략을 택하게 되면 애플리케이션의 동작이 복잡해지기는 하지만, 많은 애플리케이션에게 가장 실용적인 전략일 수 있다.

#### HTTP1.x와 HTTP2.0의 유동적인 최적화

일부 웹 최적화 프레임워크와 오픈소스 및 상용 제품들은 요청을 전달할 때에 전송할 애플리케이션 코드를 유동적으로 수정할 수 있다(파일 결합, 스프라이팅, 샤딩 등). 이러한 경우 서버가 협상된 프로토콜 버전을 적용하여 그에 따른 적절한 최적화 전략을 택할 수 있다.

#### HTTP2.0, 단일 프로토콜 사용

만약 애플리케이션이 서버와 클라이언트를 모두를 제어한다면 HTTP2.0만을 사용하지 않을 이유가 없을 것이다.

현재의 설계 구조와 애플리케이션의 복잡성, 그리고 사용자들의 요청 빈도에 따라서 위의 옵션 중에 알맞은 방법을 택해야 할 것이다. 만약 클라이언트를 제어할 수 있고 자동적으로 애플리케이션을 최적화할 수 있는 솔루션을 가지고 있거나, 애플리케이션이 1.x 고유의 최적화를 사용하고 있지 않다면 곧바로 HTTP2.0으로 옮겨가도 아무런 문제가 없을 것이다.

### 1.x에서 2.0으로, 그리고 다시 1.x으로

변환 계층을 도입하여 기존의 1.x 서버 역시 HTTP2.0의 덕을 보게 할 수 있다.

중계 서버가 HTTP2.0 세션을 받아서 처리하고 1.x 형식의 요청으로 기존의 인프라로 전송하는 것이다. 응답을 받고 나면 다시 이를 HTTP2.0으로 바꾸어 클라이언트에게 응답을 보낸다. 이렇게 하면 기존의 1.x 인프라를 거의 손대지 않으면서 재사용할 수 있기 때문에, 대부분의 경우 매우 간단하게 HTTP2.0와 작업을 시작할 수 있게 된다.

그러나 이 방식은 장기적으로 좋은 전략이 아니다. 이미 최적화되고 멀티플렉싱이 된 세션을 1.x 요청으로 이렬ㄹ로 늘어세워서 세션의 최적화를 망가뜨리는 대신, 1.x에서 2.0으로 변환해야만 한다.

### 서버 품질 성능을 평가하기

HTTP2.0 서버의 품질은 클라이언트의 성능에 큰 영향을 미치게 된다.

- HTTP2.0 서버는 스트림 우선순위를 이해해야 한다.
- HTTP2.0 서버는 응답 프로세싱과 전송의 우선순위를 정해야 한다.
- HTTP2.0 서버는 서버 푸시를 지원해야 한다.
- HTTP2.0 서버는 여러 가지 푸시 전략을 지원해야 한다.

### TLS가 있을 때와 없을 때 2.0을 사용하기

### 로드 밸런서, 프락시 그리고 애플리케이션 서버

## 참고 {docsify-ignore}

* [네트워킹과 웹 성능 최적화 기법 | 알리아 그리고릭, 인사이트](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&linkClass=3309&barcode=9788966261659)
